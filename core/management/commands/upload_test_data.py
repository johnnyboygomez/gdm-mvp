# Save this as: core/management/commands/upload_test_data.py

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from core.models import Participant
from goals.models import WeeklyGoal
import pandas as pd
import json

class Command(BaseCommand):
    help = 'Upload test data from CSV file generated by test_data_generator'

    def add_arguments(self, parser):
        parser.add_argument(
            '--csv-file',
            type=str,
            required=True,
            help='Path to CSV file created by test_data_generator'
        )
        parser.add_argument(
            '--participant-ids',
            type=str,
            help='Comma-separated participant IDs'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be uploaded without doing it'
        )
        parser.add_argument(
            '--clear-existing',
            action='store_true',
            help='Clear existing data before uploading'
        )

    def handle(self, *args, **options):
        csv_file = options['csv_file']
        dry_run = options['dry_run']
        clear_existing = options['clear_existing']

        try:
            # Read CSV
            df = pd.read_csv(csv_file)
            self.stdout.write(f"Loaded CSV: {csv_file} ({len(df)} rows)")
            
            # Show what data we have
            if len(df) > 0:
                self.stdout.write(f"Columns: {', '.join(df.columns.tolist())}")
                days_summary = df['actual_days'].value_counts().sort_index()
                self.stdout.write(f"Days distribution: {dict(days_summary)}")

            # Get participants
            if options['participant_ids']:
                participant_ids = [int(x.strip()) for x in options['participant_ids'].split(',')]
                participants = []
                for pid in participant_ids:
                    try:
                        participants.append(Participant.objects.get(id=pid))
                    except Participant.DoesNotExist:
                        self.stdout.write(self.style.ERROR(f"Participant {pid} not found"))
                        return
            else:
                participants = list(Participant.objects.all()[:len(df)])

            self.stdout.write(f"Will upload to {len(participants)} participants")

            if dry_run:
                self.stdout.write(self.style.WARNING("DRY RUN MODE"))

            # Upload data
            processed_count = 0
            with transaction.atomic():
                for i, participant in enumerate(participants):
                    if i >= len(df):
                        break
                    
                    # Skip participants with ID 1 or 47 (if you still want this)
                    if participant.id in [1, 47]:
                        self.stdout.write(self.style.WARNING(f"Skipping participant with ID {participant.id}"))
                        continue
                        
                    row = df.iloc[i]
                    
                    self.stdout.write(f"\n{participant.user.email} (ID: {participant.id})")
                    self.stdout.write(f"   Dataset: {row['test_pair']} ({row['actual_days']} days)")

                    if not dry_run:
                        # Clear existing data
                        if clear_existing:
                            participant.daily_steps = []
                            participant.targets = {}
                            participant.save()
                            self.stdout.write("   Cleared existing data")

                        # Upload step data - convert from Fitbit format to daily_steps list
                        step_data_raw = json.loads(row['data_json'])
                        # step_data_raw is now [{"date": "2025-09-03", "value": 2941}, ...]
                        
                        # Store in the Fitbit format (list of dicts) as daily_steps
                        participant.daily_steps = step_data_raw
                        self.stdout.write(f"   Uploaded {len(step_data_raw)} days of step data")

                        # Upload expected targets - ONLY WEEK 1
                        expected_goals_raw = json.loads(row['expected_goals_json'])
                        targets_dict = {}
                        
                        # Sort the goal dates and only take the first one (week 1)
                        goal_dates = sorted(expected_goals_raw.keys())
                        if goal_dates:
                            first_goal_date = goal_dates[0]  # Only take week 1 target
                            goal_data = expected_goals_raw[first_goal_date]
                            
                            if goal_data:  # Skip empty goals
                                targets_dict[first_goal_date] = {
                                    'average_steps': goal_data['average_steps'],
                                    'increase': str(goal_data['increase']),
                                    'new_target': goal_data['new_target']
                                }
                                self.stdout.write(f"   Expected target (week 1 only): {first_goal_date} -> {goal_data['new_target']} steps")
                                
                                if len(goal_dates) > 1:
                                    self.stdout.write(f"   Skipped week 2 target: {goal_dates[1]}")

                        # Save targets to database
                        participant.targets = targets_dict
                        participant.save()
                        self.stdout.write(f"   SAVED {len(targets_dict)} targets to participant.targets")
                        
                        processed_count += 1
                    else:
                        # Dry run - show what would be uploaded
                        step_data = json.loads(row['data_json'])
                        expected_goals = json.loads(row['expected_goals_json'])
                        
                        self.stdout.write(f"   Would upload {len(step_data)} days of steps")
                        self.stdout.write(f"   Would create {len([g for g in expected_goals.values() if g])} expected goals")

            if dry_run:
                self.stdout.write(f"\nDRY RUN COMPLETE - Would have processed {len(participants)} participants")
            else:
                self.stdout.write(f"\nSUCCESS! Processed {processed_count} participants")

        except Exception as e:
            raise CommandError(f'Error: {e}')