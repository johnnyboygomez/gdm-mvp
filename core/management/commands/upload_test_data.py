# Save this as: core/management/commands/upload_test_data.py

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from core.models import Participant
from goals.models import WeeklyGoal
import csv
import json
from collections import Counter

class Command(BaseCommand):
    help = 'Upload test data from CSV file generated by test_data_generator'

    def add_arguments(self, parser):
        parser.add_argument(
            '--csv-file',
            type=str,
            required=True,
            help='Path to CSV file created by test_data_generator'
        )
        parser.add_argument(
            '--participant-ids',
            type=str,
            help='Comma-separated participant IDs'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be uploaded without doing it'
        )
        parser.add_argument(
            '--clear-existing',
            action='store_true',
            help='Clear existing data before uploading'
        )

    def handle(self, *args, **options):
        csv_file = options['csv_file']
        dry_run = options['dry_run']
        clear_existing = options['clear_existing']

        try:
            # Read CSV using built-in csv module
            rows = []
            with open(csv_file, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                rows = list(reader)
                
            self.stdout.write(f"Loaded CSV: {csv_file} ({len(rows)} rows)")
            
            # Show what data we have
            if len(rows) > 0:
                columns = list(rows[0].keys())
                self.stdout.write(f"Columns: {', '.join(columns)}")
                
                # Count days distribution
                days_counts = Counter(int(row['actual_days']) for row in rows)
                self.stdout.write(f"Days distribution: {dict(sorted(days_counts.items()))}")

            # Get participants
            if options['participant_ids']:
                participant_ids = [int(x.strip()) for x in options['participant_ids'].split(',')]
                participants = []
                for pid in participant_ids:
                    try:
                        participants.append(Participant.objects.get(id=pid))
                    except Participant.DoesNotExist:
                        self.stdout.write(self.style.ERROR(f"Participant {pid} not found"))
                        return
            else:
                # Get all participants except the admin ones
                participants = list(Participant.objects.exclude(id__in=[1, 47, 49]).all()[:len(rows)])

            self.stdout.write(f"Will upload to {len(participants)} participants (excluding admin IDs 1, 47)")

            if dry_run:
                self.stdout.write(self.style.WARNING("DRY RUN MODE"))

            # Upload data
            processed_count = 0
            with transaction.atomic():
                for i, participant in enumerate(participants):
                    if i >= len(rows):
                        break
                    
                    # No need to skip here since we already excluded them in the query
                    row = rows[i]
                    
                    self.stdout.write(f"\n{participant.user.email} (ID: {participant.id})")
                    self.stdout.write(f"   Dataset: {row['test_pair']} ({row['actual_days']} days)")

                    if not dry_run:
                        # Clear existing data
                        if clear_existing:
                            participant.daily_steps = []
                            participant.targets = {}
                            participant.save()
                            self.stdout.write("   Cleared existing data")

                        # Upload step data - convert from test format to expected format
                        step_data_raw = json.loads(row['data_json'])
                        daily_steps_list = []
                        for day_entry in step_data_raw:
                            # Handle both 'date' and 'dateTime' keys from the generator
                            date_key = 'date' if 'date' in day_entry else 'dateTime'
                            daily_steps_list.append({
                                "date": day_entry[date_key],
                                "value": int(day_entry['value'])
                            })

                        participant.daily_steps = daily_steps_list
                        self.stdout.write(f"   Uploaded {len(daily_steps_list)} days of step data")
                        
                        # Upload expected targets - ONLY WEEK 1
                        expected_goals_raw = json.loads(row['expected_goals_json'])
                        targets_dict = {}
                        
                        # Sort the goal dates and only take the first one (week 1)
                        goal_dates = sorted(expected_goals_raw.keys())
                        if goal_dates:
                            first_goal_date = goal_dates[0]  # Only take week 1 target
                            goal_data = expected_goals_raw[first_goal_date]
                            
                            if goal_data:  # Skip empty goals
                                targets_dict[first_goal_date] = {
                                    'average_steps': goal_data['average_steps'],
                                    'increase': str(goal_data['increase']),
                                    'new_target': goal_data['new_target']
                                }
                                self.stdout.write(f"   Expected target (week 1 only): {first_goal_date} -> {goal_data['new_target']} steps")
                                
                                if len(goal_dates) > 1:
                                    self.stdout.write(f"   Skipped week 2 target: {goal_dates[1]}")

                        # Save targets to database
                        participant.targets = targets_dict
                        participant.save()
                        self.stdout.write(f"   SAVED {len(targets_dict)} targets to participant.targets")
                        
                        processed_count += 1
                    else:
                        # Dry run - show what would be uploaded
                        step_data = json.loads(row['data_json'])
                        expected_goals = json.loads(row['expected_goals_json'])
                        
                        self.stdout.write(f"   Would upload {len(step_data)} days of steps")
                        self.stdout.write(f"   Would create {len([g for g in expected_goals.values() if g])} expected goals")

            if dry_run:
                self.stdout.write(f"\nDRY RUN COMPLETE - Would have processed {len(participants)} participants")
            else:
                self.stdout.write(f"\nSUCCESS! Processed {processed_count} participants")

        except FileNotFoundError:
            raise CommandError(f'CSV file not found: {csv_file}')
        except Exception as e:
            raise CommandError(f'Error: {e}')