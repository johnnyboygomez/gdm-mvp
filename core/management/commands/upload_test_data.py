# Save this as: core/management/commands/upload_test_data.py

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from core.models import Participant
from goals.models import WeeklyGoal
import pandas as pd
import json

class Command(BaseCommand):
    help = 'Upload test data from CSV file generated by test_data_generator'

    def add_arguments(self, parser):
        parser.add_argument(
            '--csv-file',
            type=str,
            required=True,
            help='Path to CSV file created by test_data_generator'
        )
        parser.add_argument(
            '--participant-ids',
            type=str,
            help='Comma-separated participant IDs'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be uploaded without doing it'
        )
        parser.add_argument(
            '--clear-existing',
            action='store_true',
            help='Clear existing data before uploading'
        )

    def handle(self, *args, **options):
        csv_file = options['csv_file']
        dry_run = options['dry_run']
        clear_existing = options['clear_existing']

        try:
            # Read CSV
            df = pd.read_csv(csv_file)
            self.stdout.write(f"📊 Loaded CSV: {csv_file} ({len(df)} rows)")

            # Get data we need
            week1_data = df[df['test_type'] == 'single_week'].reset_index(drop=True)
            week2_data = df[df['test_type'] == 'two_weeks_variable'].reset_index(drop=True)

            self.stdout.write(f"Week 1 (expected goals): {len(week1_data)} datasets")
            self.stdout.write(f"Week 2 (step data): {len(week2_data)} datasets")

            # Get participants
            if options['participant_ids']:
                participant_ids = [int(x.strip()) for x in options['participant_ids'].split(',')]
                participants = []
                for pid in participant_ids:
                    try:
                        participants.append(Participant.objects.get(id=pid))
                    except Participant.DoesNotExist:
                        self.stdout.write(self.style.ERROR(f"Participant {pid} not found"))
                        return
            else:
                max_datasets = min(len(week1_data), len(week2_data))
                participants = list(Participant.objects.all()[:max_datasets])

            self.stdout.write(f"🎯 Will upload to {len(participants)} participants")

            if dry_run:
                self.stdout.write(self.style.WARNING("🧪 DRY RUN MODE"))

            # Upload data
            with transaction.atomic():
                for i, participant in enumerate(participants):
                    week1_row = week1_data.iloc[i]
                    week2_row = week2_data.iloc[i]

                    self.stdout.write(f"\n👤 {participant.user.email} (ID: {participant.id})")

                    if not dry_run:
                        # Clear existing data
                        if clear_existing:
                            participant.daily_steps = {}
                            participant.targets = {}
                            participant.save()
                            self.stdout.write("   🗑️  Cleared existing data")

                        # Upload step data
                        step_data_raw = json.loads(week2_row['data_json'])
                        daily_steps_dict = {}
                        for day_entry in step_data_raw:
                            date_key = day_entry['dateTime']
                            steps = int(day_entry['value'])
                            daily_steps_dict[date_key] = steps

                        participant.daily_steps = daily_steps_dict
                        self.stdout.write(f"   📈 Uploaded {len(daily_steps_dict)} days of step data")

                        # Upload expected targets
                        expected_goals_raw = json.loads(week1_row['expected_goals_json'])
                        targets_dict = {}
                        
                        for goal_date_str, goal_data in expected_goals_raw.items():
                            if goal_data:  # Skip empty goals
                                targets_dict[goal_date_str] = {
                                    'average_steps': goal_data['average_steps'],
                                    'increase': str(goal_data['increase']),
                                    'new_target': goal_data['new_target']
                                }
                                self.stdout.write(f"   🎯 Expected target: {goal_date_str} → {goal_data['new_target']} steps")

                        # THIS IS THE CRITICAL LINE - Save targets to database
                        participant.targets = targets_dict
                        participant.save()
                        self.stdout.write(f"   💾 SAVED {len(targets_dict)} targets to participant.targets")

            self.stdout.write(f"\n✅ SUCCESS! Processed {len(participants)} participants")

        except Exception as e:
            raise CommandError(f'Error: {e}')
            